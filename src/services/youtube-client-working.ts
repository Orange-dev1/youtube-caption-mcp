import { Innertube } from 'youtubei.js';
import type {
  VideoInfo,
  CaptionTrack,
  CaptionsList,
  CaptionSegment,
  CaptionsData,
  SearchResult,
  SearchResponse,
  RawTranscript,
  RawTranscriptSegment,
  FormattedTranscriptSegment,
} from '../types/youtube.js';
import {
  VideoNotFoundError,
  CaptionsNotAvailableError,
  AccessDeniedError,
  NetworkError,
  SystemError,
} from '../types/errors.js';
import { formatDuration, formatNumber, formatDate, cleanCaptionText } from '../utils/formatters.js';
import { normalizeLanguageCode } from '../utils/validators.js';

export class WorkingYouTubeClient {
  private innertube: Innertube | null = null;
  private initPromise: Promise<void> | null = null;

  constructor() {
    this.initPromise = this.initialize();
  }

  private async initialize(): Promise<void> {
    try {
      // Suppress parser errors during YouTube client initialization
      const consoleError = console.error;
      console.error = (...args: any[]) => {
        const message = args.join(' ');
        if (message.includes('[YOUTUBEJS][Parser]')) {
          return; // Suppress parser errors
        }
        consoleError.apply(console, args);
      };

      this.innertube = await Innertube.create({
        lang: 'ja',
        location: 'JP',
        enable_session_cache: false,
      });

      // Restore console.error
      console.error = consoleError;
    } catch (error) {
      console.error('Failed to initialize YouTube client:', error);
      throw new SystemError('Failed to initialize YouTube client', {
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  private async ensureInitialized(): Promise<Innertube> {
    if (this.initPromise) {
      await this.initPromise;
      this.initPromise = null;
    }

    if (!this.innertube) {
      throw new SystemError('YouTube client is not initialized');
    }

    return this.innertube;
  }

  // Get video information
  async getVideoInfo(videoId: string): Promise<VideoInfo> {
    try {
      const yt = await this.ensureInitialized();

      const info = await yt.getInfo(videoId);

      if (!info.basic_info) {
        throw new VideoNotFoundError(videoId);
      }

      const basicInfo = info.basic_info as any;

      // Check if video is unavailable
      if (basicInfo.is_private) {
        throw new AccessDeniedError(videoId);
      }

      // Safely access properties (using type assertion)
      const duration = basicInfo.duration?.seconds || basicInfo.duration || 0;
      const viewCount = basicInfo.view_count || 0;
      const title = basicInfo.title || 'Unknown Title';
      const description = basicInfo.short_description || '';
      const channelName = basicInfo.channel?.name || basicInfo.author || 'Unknown Channel';
      const uploadDate = basicInfo.upload_date || basicInfo.publish_date || '';
      const thumbnails = basicInfo.thumbnail || [];
      const thumbnailUrl = Array.isArray(thumbnails) && thumbnails.length > 0 ? thumbnails[0].url : '';

      return {
        id: videoId,
        title,
        description,
        channel: channelName,
        duration: formatDuration(Number(duration)),
        publishedAt: formatDate(String(uploadDate)),
        viewCount: formatNumber(Number(viewCount)),
        thumbnail: thumbnailUrl,
        language: 'ja',
      };
    } catch (error) {
      if (error instanceof VideoNotFoundError || error instanceof AccessDeniedError) {
        throw error;
      }

      console.error(`Error getting video info for ${videoId}:`, error);
      
      if (error instanceof Error && error.message.includes('network')) {
        throw new NetworkError('Network error occurred', {
          videoId,
          error: error.message,
        });
      }

      throw new SystemError('Failed to get video information', {
        videoId,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  // Get list of available captions
  async getCaptionsList(videoId: string): Promise<CaptionsList> {
    try {
      const yt = await this.ensureInitialized();

      const info = await yt.getInfo(videoId);

      if (!info.captions) {
        throw new CaptionsNotAvailableError(videoId, undefined, 'No captions exist for this video');
      }

      const captionTracks = (info.captions as any).caption_tracks;
      if (!captionTracks || captionTracks.length === 0) {
        throw new CaptionsNotAvailableError(videoId, undefined, 'No captions exist for this video');
      }

      const availableCaptions: CaptionTrack[] = captionTracks.map((track: any) => ({
        languageCode: track.language_code || 'unknown',
        languageName: track.name?.text || track.language_code || 'Unknown',
        isAutoGenerated: track.kind === 'asr',
        kind: track.kind || 'captions',
      }));

      return {
        videoId,
        availableCaptions,
        totalCount: availableCaptions.length,
      };
    } catch (error) {
      if (error instanceof CaptionsNotAvailableError) {
        throw error;
      }

      console.error(`Error getting captions list for ${videoId}:`, error);
      throw new SystemError('Failed to get captions list', {
        videoId,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  // Download caption data
  async downloadCaptions(
    videoId: string,
    language: string = 'ja',
    format: 'raw' | 'srt' | 'vtt' = 'raw'
  ): Promise<CaptionsData> {
    try {
      const yt = await this.ensureInitialized();
      const normalizedLang = normalizeLanguageCode(language);

      const info = await yt.getInfo(videoId);
      console.log(`[downloadCaptions] Got video info, captions available: ${!!info.captions}`);

      if (!info.captions) {
        throw new CaptionsNotAvailableError(videoId, normalizedLang, 'No captions exist for this video');
      }

      // Search for caption track in specified language
      const captionTracks = (info.captions as any).caption_tracks;
      console.log(`[downloadCaptions] Caption tracks found: ${captionTracks?.length || 0}`);
      if (captionTracks?.length > 0) {
        console.log(`[downloadCaptions] Available languages: ${captionTracks.map((t: any) => t.language_code).join(', ')}`);
      }
      if (!captionTracks) {
        throw new CaptionsNotAvailableError(videoId, normalizedLang, 'No captions exist for this video');
      }

      let targetTrack = captionTracks.find((track: any) => 
        track.language_code === normalizedLang
      );
      console.log(`[downloadCaptions] Exact match for ${normalizedLang}: ${!!targetTrack}`);

      // If no exact match, try partial match
      if (!targetTrack) {
        const langPrefix = normalizedLang.split('-')[0];
        targetTrack = captionTracks.find((track: any) => 
          langPrefix && track.language_code?.startsWith(langPrefix)
        );
        console.log(`[downloadCaptions] Partial match for ${langPrefix}: ${!!targetTrack}`);
      }

      // If still not found, try default language
      if (!targetTrack && normalizedLang !== 'ja') {
        targetTrack = captionTracks.find((track: any) => 
          track.language_code === 'ja' || track.language_code?.startsWith('ja')
        );
        console.log(`[downloadCaptions] Fallback to Japanese: ${!!targetTrack}`);
      }

      if (!targetTrack) {
        console.log(`[downloadCaptions] No suitable track found for language: ${normalizedLang}`);
        throw new CaptionsNotAvailableError(videoId, normalizedLang, `Captions for specified language (${normalizedLang}) not found`);
      }

      console.log(`[downloadCaptions] Selected track: ${targetTrack.language_code}, kind: ${targetTrack.kind}`);

      // Get caption data
      try {
        console.log(`[downloadCaptions] Attempting to get transcript...`);
        const transcript = await info.getTranscript();
        console.log(`[downloadCaptions] Transcript received: ${!!transcript}`);
        if (!transcript) {
          throw new CaptionsNotAvailableError(videoId, normalizedLang, 'Failed to get caption data');
        }

        // Debug: Log transcript structure in more detail
        console.log(`[downloadCaptions] Transcript body structure:`, transcript as any ? 'exists' : 'not exists');
        if ((transcript as any)?.body?.initial_segments) {
          console.log(`[downloadCaptions] Initial segments count:`, (transcript as any)?.body.initial_segments.length);
          console.log(`[downloadCaptions] First segment sample:`, JSON.stringify((transcript as any)?.body.initial_segments[0], null, 2));
        }
        
        // Extract segments directly from transcript data
        let initialSegments: any[] = [];
        
        // Get transcriptData appropriately
        const transcriptData = transcript as any;
        
        // Check multiple possible structures
        if (transcriptData?.transcript?.content?.body?.initial_segments) {
          initialSegments = transcriptData.transcript.content.body.initial_segments;
          console.log(`[downloadCaptions] Found segments in transcript.content.body.initial_segments: ${initialSegments.length}`);
        } else if (transcriptData?.content?.body?.initial_segments) {
          initialSegments = transcriptData.content.body.initial_segments;
          console.log(`[downloadCaptions] Found segments in content.body.initial_segments: ${initialSegments.length}`);
        } else if (transcriptData?.body?.initial_segments) {
          initialSegments = transcriptData.body.initial_segments;
          console.log(`[downloadCaptions] Found segments in body.initial_segments: ${initialSegments.length}`);
        } else if (transcriptData?.initial_segments) {
          initialSegments = transcriptData.initial_segments;
          console.log(`[downloadCaptions] Found segments in initial_segments: ${initialSegments.length}`);
        } else if (Array.isArray(transcriptData)) {
          initialSegments = transcriptData;
          console.log(`[downloadCaptions] Found segments as array: ${initialSegments.length}`);
        } else {
          console.error(`[downloadCaptions] Unexpected transcript structure. Keys:`, Object.keys(transcriptData || {}));
          console.error(`[downloadCaptions] Sample transcript data:`, JSON.stringify(transcriptData, null, 2).substring(0, 1000));
        }
        
        // Convert segment data to appropriate format
        const segments: CaptionSegment[] = [];
        
        if (initialSegments && initialSegments.length > 0) {
          initialSegments.forEach((segment: any, index: number) => {
            try {
              // Check segment type
              if (segment.type !== 'TranscriptSegment') {
                return; // Skip non-TranscriptSegment
              }
              
              // Extract text (from snippet.text)
              const text = segment.snippet?.text || '';
              if (!text || !text.trim()) {
                return; // Skip empty text
              }
              
              // Extract timing information
              const startMs = parseInt(segment.start_ms || '0');
              const endMs = parseInt(segment.end_ms || segment.start_ms || '0');
              const start = startMs / 1000;
              const duration = Math.max(0.1, (endMs - startMs) / 1000); // Minimum 0.1 seconds
              
              const segmentData: CaptionSegment = {
                text: cleanCaptionText(text),
                start,
                duration,
              };
              
              segments.push(segmentData);
              
              // Debug output for first few segments
              if (index < 3) {
                console.log(`[downloadCaptions] Segment ${index}:`, {
                  text: segmentData.text,
                  start: segmentData.start,
                  duration: segmentData.duration
                });
              }
            } catch (segmentError) {
              console.warn(`[downloadCaptions] Error processing segment ${index}:`, segmentError);
            }
          });
        }

        console.log(`[downloadCaptions] Extracted ${segments.length} segments`);
        if (segments.length === 0) {
          console.error(`[downloadCaptions] No segments found. Transcript keys:`, Object.keys(transcript));
          console.error(`[downloadCaptions] Full transcript structure:`, JSON.stringify(transcript, null, 2));
          throw new CaptionsNotAvailableError(videoId, normalizedLang, 'Caption data is empty');
        }

        return {
          videoId,
          language: targetTrack.language_code || normalizedLang,
          format,
          isAutoGenerated: targetTrack.kind === 'asr',
          segments,
        };
      } catch (transcriptError) {
        console.error(`[downloadCaptions] Error getting transcript:`, transcriptError);
        throw new CaptionsNotAvailableError(videoId, normalizedLang, 'Failed to get caption data');
      }
    } catch (error) {
      if (error instanceof CaptionsNotAvailableError) {
        throw error;
      }

      console.error(`Error downloading captions for ${videoId}:`, error);
      throw new SystemError('Failed to download caption data', {
        videoId,
        language,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  // Search for videos with captions
  async searchVideosWithCaptions(
    query: string,
    language?: string | null,
    limit: number = 10
  ): Promise<SearchResponse> {
    try {
      const yt = await this.ensureInitialized();

      const searchResults = await yt.search(query, {
        type: 'video',
      });

      if (!searchResults.videos) {
        return {
          query,
          results: [],
          totalCount: 0,
        };
      }

      const results: SearchResult[] = [];
      const videos = searchResults.videos.slice(0, limit);

      for (const video of videos) {
        try {
          // Safely get video ID (using type assertion)
          const videoData = video as any;
          let videoId: string;
          
          if (typeof videoData.id === 'string') {
            videoId = videoData.id;
          } else if (videoData.id?.videoId) {
            videoId = videoData.id.videoId;
          } else if (videoData.basic_info?.id) {
            videoId = videoData.basic_info.id;
          } else {
            continue; // Skip if ID cannot be obtained
          }

          // Get caption information for each video
          const captionsList = await this.getCaptionsList(videoId);
          
          // Only include results with captions in specified language
          let includeCaptions = captionsList.availableCaptions;
          if (language != null && language.trim()) {
            const normalizedLang = normalizeLanguageCode(language.trim());
            const langPrefix = normalizedLang.split('-')[0];
            includeCaptions = captionsList.availableCaptions.filter(caption =>
              caption.languageCode === normalizedLang ||
              (langPrefix && caption.languageCode.startsWith(langPrefix))
            );
          }

          if (includeCaptions.length > 0) {
            const title = videoData.title?.text || videoData.title || 'Unknown Title';
            const channelName = videoData.author?.name || videoData.channel?.name || 'Unknown Channel';
            const duration = videoData.duration?.seconds_total || videoData.duration?.seconds || 0;
            const thumbnails = videoData.thumbnails || [];
            const thumbnailUrl = Array.isArray(thumbnails) && thumbnails.length > 0 ? thumbnails[0].url : '';

            results.push({
              videoId,
              title,
              channel: channelName,
              duration: formatDuration(Number(duration)),
              thumbnail: thumbnailUrl,
              availableCaptions: includeCaptions,
            });
          }
        } catch (error) {
          // Continue search even if individual video has error
          if (!(error instanceof CaptionsNotAvailableError)) {
            console.warn(`Failed to get captions for video:`, error);
          }
        }
      }

      return {
        query,
        results,
        totalCount: results.length,
      };
    } catch (error) {
      console.error(`Error searching videos with captions:`, error);
      throw new SystemError('Failed to search videos with captions', {
        query,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }
}

// Default YouTube client instance (working version)
export const workingYouTubeClient = new WorkingYouTubeClient();
