import { Innertube } from 'youtubei.js';
import type {
  VideoInfo,
  CaptionTrack,
  CaptionsList,
  CaptionSegment,
  CaptionsData,
  SearchResult,
  SearchResponse,
  RawTranscript,
  RawTranscriptSegment,
  FormattedTranscriptSegment,
} from '../types/youtube.js';
import {
  VideoNotFoundError,
  CaptionsNotAvailableError,
  AccessDeniedError,
  NetworkError,
  SystemError,
} from '../types/errors.js';
import { formatDuration, formatNumber, formatDate, cleanCaptionText } from '../utils/formatters.js';
import { normalizeLanguageCode } from '../utils/validators.js';

export class WorkingYouTubeClient {
  private innertube: Innertube | null = null;
  private initPromise: Promise<void> | null = null;

  constructor() {
    this.initPromise = this.initialize();
  }

  private async initialize(): Promise<void> {
    try {
      // YouTubeクライアントの初期化時にパーサーエラーを抑制
      const consoleError = console.error;
      console.error = (...args: any[]) => {
        const message = args.join(' ');
        if (message.includes('[YOUTUBEJS][Parser]')) {
          return; // パーサーエラーを抑制
        }
        consoleError.apply(console, args);
      };

      this.innertube = await Innertube.create({
        lang: 'ja',
        location: 'JP',
        enable_session_cache: false,
      });

      // console.errorを元に戻す
      console.error = consoleError;
    } catch (error) {
      console.error('Failed to initialize YouTube client:', error);
      throw new SystemError('YouTubeクライアントの初期化に失敗しました', {
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  private async ensureInitialized(): Promise<Innertube> {
    if (this.initPromise) {
      await this.initPromise;
      this.initPromise = null;
    }

    if (!this.innertube) {
      throw new SystemError('YouTubeクライアントが初期化されていません');
    }

    return this.innertube;
  }

  // 動画情報を取得
  async getVideoInfo(videoId: string): Promise<VideoInfo> {
    try {
      const yt = await this.ensureInitialized();

      const info = await yt.getInfo(videoId);

      if (!info.basic_info) {
        throw new VideoNotFoundError(videoId);
      }

      const basicInfo = info.basic_info as any;

      // 動画が利用できない場合のチェック
      if (basicInfo.is_private) {
        throw new AccessDeniedError(videoId);
      }

      // 安全にプロパティにアクセス（型アサーションを使用）
      const duration = basicInfo.duration?.seconds || basicInfo.duration || 0;
      const viewCount = basicInfo.view_count || 0;
      const title = basicInfo.title || 'タイトル不明';
      const description = basicInfo.short_description || '';
      const channelName = basicInfo.channel?.name || basicInfo.author || 'チャンネル不明';
      const uploadDate = basicInfo.upload_date || basicInfo.publish_date || '';
      const thumbnails = basicInfo.thumbnail || [];
      const thumbnailUrl = Array.isArray(thumbnails) && thumbnails.length > 0 ? thumbnails[0].url : '';

      return {
        id: videoId,
        title,
        description,
        channel: channelName,
        duration: formatDuration(Number(duration)),
        publishedAt: formatDate(String(uploadDate)),
        viewCount: formatNumber(Number(viewCount)),
        thumbnail: thumbnailUrl,
        language: 'ja',
      };
    } catch (error) {
      if (error instanceof VideoNotFoundError || error instanceof AccessDeniedError) {
        throw error;
      }

      console.error(`Error getting video info for ${videoId}:`, error);
      
      if (error instanceof Error && error.message.includes('network')) {
        throw new NetworkError('ネットワークエラーが発生しました', {
          videoId,
          error: error.message,
        });
      }

      throw new SystemError('動画情報の取得に失敗しました', {
        videoId,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  // 利用可能な字幕一覧を取得
  async getCaptionsList(videoId: string): Promise<CaptionsList> {
    try {
      const yt = await this.ensureInitialized();

      const info = await yt.getInfo(videoId);

      if (!info.captions) {
        throw new CaptionsNotAvailableError(videoId, undefined, 'この動画には字幕が存在しません');
      }

      const captionTracks = (info.captions as any).caption_tracks;
      if (!captionTracks || captionTracks.length === 0) {
        throw new CaptionsNotAvailableError(videoId, undefined, 'この動画には字幕が存在しません');
      }

      const availableCaptions: CaptionTrack[] = captionTracks.map((track: any) => ({
        languageCode: track.language_code || 'unknown',
        languageName: track.name?.text || track.language_code || 'Unknown',
        isAutoGenerated: track.kind === 'asr',
        kind: track.kind || 'captions',
      }));

      return {
        videoId,
        availableCaptions,
        totalCount: availableCaptions.length,
      };
    } catch (error) {
      if (error instanceof CaptionsNotAvailableError) {
        throw error;
      }

      console.error(`Error getting captions list for ${videoId}:`, error);
      throw new SystemError('字幕一覧の取得に失敗しました', {
        videoId,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  // 字幕データをダウンロード
  async downloadCaptions(
    videoId: string,
    language: string = 'ja',
    format: 'raw' | 'srt' | 'vtt' = 'raw'
  ): Promise<CaptionsData> {
    try {
      const yt = await this.ensureInitialized();
      const normalizedLang = normalizeLanguageCode(language);

      const info = await yt.getInfo(videoId);
      console.log(`[downloadCaptions] Got video info, captions available: ${!!info.captions}`);

      if (!info.captions) {
        throw new CaptionsNotAvailableError(videoId, normalizedLang, 'この動画には字幕が存在しません');
      }

      // 指定された言語の字幕トラックを検索
      const captionTracks = (info.captions as any).caption_tracks;
      console.log(`[downloadCaptions] Caption tracks found: ${captionTracks?.length || 0}`);
      if (captionTracks?.length > 0) {
        console.log(`[downloadCaptions] Available languages: ${captionTracks.map((t: any) => t.language_code).join(', ')}`);
      }
      if (!captionTracks) {
        throw new CaptionsNotAvailableError(videoId, normalizedLang, 'この動画には字幕が存在しません');
      }

      let targetTrack = captionTracks.find((track: any) => 
        track.language_code === normalizedLang
      );
      console.log(`[downloadCaptions] Exact match for ${normalizedLang}: ${!!targetTrack}`);

      // 完全一致しない場合、部分一致を試す
      if (!targetTrack) {
        const langPrefix = normalizedLang.split('-')[0];
        targetTrack = captionTracks.find((track: any) => 
          langPrefix && track.language_code?.startsWith(langPrefix)
        );
        console.log(`[downloadCaptions] Partial match for ${langPrefix}: ${!!targetTrack}`);
      }

      // それでも見つからない場合、デフォルト言語を試す
      if (!targetTrack && normalizedLang !== 'ja') {
        targetTrack = captionTracks.find((track: any) => 
          track.language_code === 'ja' || track.language_code?.startsWith('ja')
        );
        console.log(`[downloadCaptions] Fallback to Japanese: ${!!targetTrack}`);
      }

      if (!targetTrack) {
        console.log(`[downloadCaptions] No suitable track found for language: ${normalizedLang}`);
        throw new CaptionsNotAvailableError(videoId, normalizedLang, `指定された言語(${normalizedLang})の字幕が見つかりません`);
      }

      console.log(`[downloadCaptions] Selected track: ${targetTrack.language_code}, kind: ${targetTrack.kind}`);

      // 字幕データを取得
      try {
        console.log(`[downloadCaptions] Attempting to get transcript...`);
        const transcript = await info.getTranscript();
        console.log(`[downloadCaptions] Transcript received: ${!!transcript}`);
        if (!transcript) {
          throw new CaptionsNotAvailableError(videoId, normalizedLang, '字幕データの取得に失敗しました');
        }

        // デバッグ用: transcript の構造をより詳細にログ出力
        console.log(`[downloadCaptions] Transcript body structure:`, transcript as any ? 'exists' : 'not exists');
        if ((transcript as any)?.body?.initial_segments) {
          console.log(`[downloadCaptions] Initial segments count:`, (transcript as any)?.body.initial_segments.length);
          console.log(`[downloadCaptions] First segment sample:`, JSON.stringify((transcript as any)?.body.initial_segments[0], null, 2));
        }
        
        // transcriptデータから直接セグメントを抽出
        let initialSegments: any[] = [];
        
        // transcriptDataを適切に取得
        const transcriptData = transcript as any;
        
        // 複数の可能な構造をチェック
        if (transcriptData?.transcript?.content?.body?.initial_segments) {
          initialSegments = transcriptData.transcript.content.body.initial_segments;
          console.log(`[downloadCaptions] Found segments in transcript.content.body.initial_segments: ${initialSegments.length}`);
        } else if (transcriptData?.content?.body?.initial_segments) {
          initialSegments = transcriptData.content.body.initial_segments;
          console.log(`[downloadCaptions] Found segments in content.body.initial_segments: ${initialSegments.length}`);
        } else if (transcriptData?.body?.initial_segments) {
          initialSegments = transcriptData.body.initial_segments;
          console.log(`[downloadCaptions] Found segments in body.initial_segments: ${initialSegments.length}`);
        } else if (transcriptData?.initial_segments) {
          initialSegments = transcriptData.initial_segments;
          console.log(`[downloadCaptions] Found segments in initial_segments: ${initialSegments.length}`);
        } else if (Array.isArray(transcriptData)) {
          initialSegments = transcriptData;
          console.log(`[downloadCaptions] Found segments as array: ${initialSegments.length}`);
        } else {
          console.error(`[downloadCaptions] Unexpected transcript structure. Keys:`, Object.keys(transcriptData || {}));
          console.error(`[downloadCaptions] Sample transcript data:`, JSON.stringify(transcriptData, null, 2).substring(0, 1000));
        }
        
        // セグメントデータを適切なフォーマットに変換
        const segments: CaptionSegment[] = [];
        
        if (initialSegments && initialSegments.length > 0) {
          initialSegments.forEach((segment: any, index: number) => {
            try {
              // セグメントタイプをチェック
              if (segment.type !== 'TranscriptSegment') {
                return; // TranscriptSegment以外はスキップ
              }
              
              // テキストを抽出（snippet.text から）
              const text = segment.snippet?.text || '';
              if (!text || !text.trim()) {
                return; // 空のテキストはスキップ
              }
              
              // 時間情報を抽出
              const startMs = parseInt(segment.start_ms || '0');
              const endMs = parseInt(segment.end_ms || segment.start_ms || '0');
              const start = startMs / 1000;
              const duration = Math.max(0.1, (endMs - startMs) / 1000); // 最小0.1秒
              
              const segmentData: CaptionSegment = {
                text: cleanCaptionText(text),
                start,
                duration,
              };
              
              segments.push(segmentData);
              
              // 最初の数セグメントをデバッグ出力
              if (index < 3) {
                console.log(`[downloadCaptions] Segment ${index}:`, {
                  text: segmentData.text,
                  start: segmentData.start,
                  duration: segmentData.duration
                });
              }
            } catch (segmentError) {
              console.warn(`[downloadCaptions] Error processing segment ${index}:`, segmentError);
            }
          });
        }

        console.log(`[downloadCaptions] Extracted ${segments.length} segments`);
        if (segments.length === 0) {
          console.error(`[downloadCaptions] No segments found. Transcript keys:`, Object.keys(transcript));
          console.error(`[downloadCaptions] Full transcript structure:`, JSON.stringify(transcript, null, 2));
          throw new CaptionsNotAvailableError(videoId, normalizedLang, '字幕データが空です');
        }

        return {
          videoId,
          language: targetTrack.language_code || normalizedLang,
          format,
          isAutoGenerated: targetTrack.kind === 'asr',
          segments,
        };
      } catch (transcriptError) {
        console.error(`[downloadCaptions] Error getting transcript:`, transcriptError);
        throw new CaptionsNotAvailableError(videoId, normalizedLang, '字幕データの取得に失敗しました');
      }
    } catch (error) {
      if (error instanceof CaptionsNotAvailableError) {
        throw error;
      }

      console.error(`Error downloading captions for ${videoId}:`, error);
      throw new SystemError('字幕データのダウンロードに失敗しました', {
        videoId,
        language,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  // 字幕付き動画を検索
  async searchVideosWithCaptions(
    query: string,
    language?: string | null,
    limit: number = 10
  ): Promise<SearchResponse> {
    try {
      const yt = await this.ensureInitialized();

      const searchResults = await yt.search(query, {
        type: 'video',
      });

      if (!searchResults.videos) {
        return {
          query,
          results: [],
          totalCount: 0,
        };
      }

      const results: SearchResult[] = [];
      const videos = searchResults.videos.slice(0, limit);

      for (const video of videos) {
        try {
          // 動画IDを安全に取得（型アサーションを使用）
          const videoData = video as any;
          let videoId: string;
          
          if (typeof videoData.id === 'string') {
            videoId = videoData.id;
          } else if (videoData.id?.videoId) {
            videoId = videoData.id.videoId;
          } else if (videoData.basic_info?.id) {
            videoId = videoData.basic_info.id;
          } else {
            continue; // IDが取得できない場合はスキップ
          }

          // 各動画の字幕情報を取得
          const captionsList = await this.getCaptionsList(videoId);
          
          // 指定された言語の字幕がある場合のみ結果に含める
          let includeCaptions = captionsList.availableCaptions;
          if (language != null && language.trim()) {
            const normalizedLang = normalizeLanguageCode(language.trim());
            const langPrefix = normalizedLang.split('-')[0];
            includeCaptions = captionsList.availableCaptions.filter(caption =>
              caption.languageCode === normalizedLang ||
              (langPrefix && caption.languageCode.startsWith(langPrefix))
            );
          }

          if (includeCaptions.length > 0) {
            const title = videoData.title?.text || videoData.title || 'タイトル不明';
            const channelName = videoData.author?.name || videoData.channel?.name || 'チャンネル不明';
            const duration = videoData.duration?.seconds_total || videoData.duration?.seconds || 0;
            const thumbnails = videoData.thumbnails || [];
            const thumbnailUrl = Array.isArray(thumbnails) && thumbnails.length > 0 ? thumbnails[0].url : '';

            results.push({
              videoId,
              title,
              channel: channelName,
              duration: formatDuration(Number(duration)),
              thumbnail: thumbnailUrl,
              availableCaptions: includeCaptions,
            });
          }
        } catch (error) {
          // 個別の動画でエラーが発生しても検索全体は続行
          if (!(error instanceof CaptionsNotAvailableError)) {
            console.warn(`Failed to get captions for video:`, error);
          }
        }
      }

      return {
        query,
        results,
        totalCount: results.length,
      };
    } catch (error) {
      console.error(`Error searching videos with captions:`, error);
      throw new SystemError('字幕付き動画の検索に失敗しました', {
        query,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }
}

// デフォルトのYouTubeクライアントインスタンス（動作版）
export const workingYouTubeClient = new WorkingYouTubeClient();
